1. 선택 정렬
> 원소를 하나씩 확인해 최댓값을 찾아서 오른쪽과 자리를 바꾼다.
> 시간복잡도: 세타(n^) = n + n-1 + n-2 + ... + 1

2. 버블 정렬
> 이웃한 두 수를 비교하여 제일 큰 원소를 오른쪽 끝으로 보냄
> 시간복잡도: 세타(n^)

3. 삽입 정렬
> 정렬된 리스트의 하나씩 늘리며, 늘릴 때마다 포함되는 원소를 알맞은 자리에 넣기
> 시간복잡도 Average, Worst: 세타(n*), Best: 세타(n) - 이미 다 정렬된 경우

4. 병합 정렬
> 원소 리스트를 반으로 나눈 후 전반부와 후반부를 독립적으로 정렬
> 시간복잡도: 세타(nlogn)
> 단점: 보조리스트가 필요함, 추가 공간 필요, 복사 과정 발생

5. 퀵 정렬
> 기준 원소를 중심으로 작은 원소들은 왼쪽으로, 큰 원소들은 오른쪽으로 오도록 재배치, 왼쪽과 오른쪽을 독립적으로 정렬
> 시간복잡도: Average, Best: 세타(nlogn), Worst: 세타(n^)
> Worst case: 분할이 균등하괴 되지 않는 경우, 모두 역정렬 되어 있을 때, 모든 원소가 동일한 경우
> 해결: 피벗 원소를 임의로 선택, 피벗 원소와 동일 원소가 나왔을 때는 양쪽으로 적절히 보내기

6. 힙 정렬
> 

7. 쉘 정렬
> n 칸 떨어져 있는 원소끼리 삽입정렬
> 시간복잡도: 오메가(nlogn), gap에 따라 시간복잡도가 달라짐


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


고급 알고리즘 > 보통 세타(nlogn)의 시간복잡도, 최악의 경우 세타(n)
> 계수 정렬: 원소들의 크기가 -O(n) ~ O(n) 정수 범위에 있을 때
> 기수 정렬: 원소들이 모두 k 이하의 자리수를 가졌을 때
> 버킷 정렬: 원소들이 균등 분포를 이룰 때

1. 계수 정렬: 원소가 각각 몇 번 나타나는지 카운트, 리스트의 원소가 몇 번째 자리에 놓이면 되느지 계산 가능

2. 기수 정렬: 자릿수만큼 리스트 생성, 자릿수끼리 비교

3. 버킷 정렬: 각 원소에 리스트 사이즈를 곱하여 정수부만 취함, 