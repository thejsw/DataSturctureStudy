그래프: 사물을 정점과 간선으로 표현 > 정점: 대상, 간선: 관계 / 방향 유무, 가중치 유무 
인접 행렬: 행렬로 관계를 표현, 방향이 없다면 대칭 행렬 > 장점: 즉각적, 단점: 행렬 유지를 위한 세타(n^) 시간과 공간 필요 > 간선의 밀도가 높은 그래프에 적합, 높지 않다면 공간 낭비가 심함
인접 리스트: 연결리스트로 관게 표현 > 공간 낭비가 거의 없음, 간선의 밀도가 낮은 그래프에 적합, 단점: 연결을 위한 공간 필요 > 밀도가 높을수록 성능 저하, 시간 복잡도 - O(n)
인접 배열: 배열로 관계 표현 > 연결을 위한 공간 절약, 메모리의 공간 지역성 향상(배열 할당), 단점: 수정이 어려움 > 그래프가 한번 만들어진 후 변하지 않는 경우에 적합, 시간 복잡도 - O(logn), 이진 검색으로 탐색 가능
인접 해시 테이블: O(logn), 인접 배열을 각각 해시 테이블로 대체, 해시 함수, 적재율 최적화에 용이, 단점: 탐색이 비효율적(해시함수로 탐색하기 때문에 왔다갔다 함)

그래프 순회: 한 정점에서 시작하여 도달 가능한 모든 정점 방문
너비 우선 탐색(BFS) : layer
깊이 우선 탐색(DFS) : 끝까지 가고 다시 돌아오는 구조, 세타(V+E)
https://devuna.tistory.com/32

연결 그래프: 간선이 모두 연결된 그래프, 최소 간선의 수: 정점 - 1
프림 알고리즘: O(ElogV)
크루스칼 알고리즘: 간선 정렬 시간이 시간복잡도 결정 > O(ElogV), 이후 최소 값을 가진 간선을 제거하며 집합 정보 업데이트 O(E + VlogV)
위상 정렬: 선후 관계가 있는 정렬, 세타(V+E)