배열과 연결리스트 > 세타(n)
이진 검색 트리 > 평균: 세타(logn), 최악: 세타(n)
균형 이진 트리 > 최악: 세타(logn)
해시 테이블 > 평균: 세타(1) >> 시간복잡도가 굉장히 낮음

해시는 키가 저장될 자리를 키의 값으로 결정
해시는 저장된 자료와 비교하지 않고 저장 위치 결정
>> 시간복잡도가 낮은 이유

단 한 번의 계산으로 자리를 찾는 것을 목표함
해시 값(자리)은 해시 함수로 계산됨 > 다른 값인데 동일한 위치에 저장될 수 있음(충돌) > 충돌을 해결할 방법?

적재율: 해시 테이블에 원소가 차 있는 비율 > 원소가 꽉 차 있을 경우 충돌이 일어날 수 밖에 없음
해시 테이블의 크기: m, 저장된 키의 수: n, 적재율 = n/m > 1/2 이상일 경우 성능이 나빠짐 > 해시 테이블의 크기를 키워줘야 함



객체 구조
__table[] : 해시 테이블로 사용하는 배열
__numItems : 해시 테이블의 원소 개수 (키의 개수)

해시 함수: 킷값을 입력받아 해시 테이블 주소로 리턴(매핑)
> 입력 키를 해시 테이블 전체에 고루 분산시켜 저장해야 좋은 함수
> 두 키가 상대적으로 비슷하다고 해싯값(주소)이 비슷하면 안됨
> 나누기 방법과 곱하기 방법이 있음

나누기 방법: x % m (나머지로 해싯 값 결정) > 큰 수를 해시 테이블 범위 내에 들어오도록 수축
m은 해시 테이블의 크기 > 1과 2가 아닌 소수(2의 멱수가 아닌 수)를 선택하는 것이 좋음 > 2의 멱수는 분산에 이상적이지 않음 > 컴퓨터 내부 연산에서 2의 배수/멱수를 자주 사용하기 때문
곱하기 방법: ((x * A)의 소수부 * m)의 정수부 > x는 입력값, A는 0과 1 사이의 소수, m은 해시 테이블 크기



충돌: 동일한 주소에 2개 이상의 키가 해싱되는 상황
> 1. 체이닝 2. Open addressing

체이닝: 같은 주소로 해싱되는 키를 하나의 연결리스트로 관리 ex) 7번 해시 테이블[키1 -> 키2 -> 키3 -> 키4]

Open addressing: 주어진 배열 안에서 해결, 충돌 발생 시 다음 주소 결정 > 선형 탐색 / 이차원 탐색 / 더블 해싱 중 1 선택
> 1. 선형탐색: (h(x) + ai + b) % m > 칸이 채워져 있으면 계속 다음 칸으로 이동(얼만큼 이동할지는 매핑 방식에 따라 달라짐) > 1차 군집(한쪽부분에만 몰리는 현상)에 취약 > 안채워진 곳까지 계속 탐색해야 하기 때문에 성능이 저하)
> 2. 이차원탐색: (h(x) + ai^ + bi + c) % m > 먼 곳으로 이동해서 탐색 > 여러 키가 동일한 해시 함숫값을 가지면 비효율적(계속 이동해야 하기 때문에), 2차 군집에 취약
> 3. 더블 해싱: (h(x) + i*f(x)) % m > h(x)와 f(x)는 서로 다른 해싱 함수 > h(x) = x % m (m은 소수), f(x) = (x % m') + 1 (m'은 m보다 작은 소수)/ f(x)와 m은 서로소여야 함 > 최소공약수 d를 가지면, 1/d 공간만 탐색하게 됨
삭제 시 주의할 점: 삭제하려는 원소를 삭제한 후, 삭제된 자리를 null로 채우면, 검색 시 존재하는 원소를 없다고 대답할 수 있다.(다음 탐색을 안하기 때문에)
> 즉 지운 자리를 DELETED라는 문자열로 채워줘야함.
적재율에 따른 성능 저하 심함 > 상한 기준을 설정하고, 이를 넘으면 테이블 크기를 대략 두 배로 키움, 테이블의 모든 원소를 다시 해싱해서 저장